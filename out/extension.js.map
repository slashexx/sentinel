{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/security.ts", "../src/parser/yaraParser.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\r\nimport { checkForSecurityIssues } from './security';\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n    console.log('Sentinel is now active!');\r\n\r\n    let disposable = vscode.workspace.onDidChangeTextDocument(event => {\r\n        checkForSecurityIssues(event.document);\r\n    });\r\n\r\n    // Also check when a document is opened\r\n    vscode.workspace.onDidOpenTextDocument(document => {\r\n        checkForSecurityIssues(document);\r\n    });\r\n\r\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection(\"sentinel\");\r\n    context.subscriptions.push(diagnosticCollection);\r\n\r\n    context.subscriptions.push(disposable);\r\n}\r\n\r\nexport function deactivate() {}\r\n", "import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { parseYaraFile } from './parser/yaraParser';\r\nimport { YaraRule } from './types/yara';\r\n\r\nexport function checkForSecurityIssues(document: vscode.TextDocument) {\r\n    const languageId = document.languageId;\r\n    const rulesPath = path.join(__dirname, '..', 'rules', `${languageId}.yar`); // Note: changed extension to .yar\r\n    \r\n    console.log(`Checking document with language: ${languageId}`);\r\n    console.log(`Looking for rules at: ${rulesPath}`);\r\n    \r\n    let rules: YaraRule[] = [];\r\n    try {\r\n        rules = parseYaraFile(rulesPath);\r\n        console.log(`Loaded ${rules.length} rules for ${languageId}`);\r\n    } catch (error) {\r\n        console.error(`Error loading YARA rules:`, error);\r\n        return;\r\n    }\r\n\r\n    const text = document.getText();\r\n    const diagnostics: vscode.Diagnostic[] = [];\r\n\r\n    rules.forEach((rule) => {\r\n        console.log(`Applying rule: ${rule.name}`);\r\n        rule.strings.forEach((str) => {\r\n            const regex = str.isRegex ? new RegExp(str.value, 'g') : new RegExp(escapeRegExp(str.value), 'g');\r\n            console.log(`Checking pattern: ${regex}`);\r\n            let match;\r\n            \r\n            while ((match = regex.exec(text)) !== null) {\r\n                console.log(`Found match at index ${match.index}:`, match[0]);\r\n                const pos = document.positionAt(match.index);\r\n                const endPos = document.positionAt(match.index + match[0].length);\r\n                \r\n                diagnostics.push(new vscode.Diagnostic(\r\n                    new vscode.Range(pos, endPos),\r\n                    `\u26A0\uFE0F ${rule.name}: ${rule.metadata?.description || 'Security issue detected'}`,\r\n                    rule.metadata?.severity === 'high' \r\n                        ? vscode.DiagnosticSeverity.Error \r\n                        : vscode.DiagnosticSeverity.Warning\r\n                ));\r\n            }\r\n        });\r\n    });\r\n\r\n    console.log(`Found ${diagnostics.length} issues`);\r\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection(\"sentinel\");\r\n    diagnosticCollection.set(document.uri, diagnostics);\r\n}\r\n\r\nfunction escapeRegExp(string: string): string {\r\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n", "import * as fs from 'fs';\r\nimport { YaraRule, YaraString } from '../types/yara';\r\n\r\nexport function parseYaraFile(filePath: string): YaraRule[] {\r\n    console.log(`Attempting to parse YARA file: ${filePath}`);\r\n    const content = fs.readFileSync(filePath, 'utf8');\r\n    console.log('File content:', content);\r\n    \r\n    const rules: YaraRule[] = [];\r\n    const ruleBlocks = content.split(/rule\\s+/).filter(block => block.trim());\r\n    console.log(`Found ${ruleBlocks.length} rule blocks`);\r\n    \r\n    for (const block of ruleBlocks) {\r\n        console.log('Parsing rule block:', block);\r\n        const rule = parseRuleBlock(block);\r\n        if (rule) {\r\n            console.log('Successfully parsed rule:', rule);\r\n            rules.push(rule);\r\n        } else {\r\n            console.log('Failed to parse rule block');\r\n        }\r\n    }\r\n    \r\n    return rules;\r\n}\r\n\r\nfunction parseRuleBlock(block: string): YaraRule | null {\r\n    const nameMatch = block.match(/^(\\w+)\\s*{/);\r\n    if (!nameMatch) {\r\n        console.log('Failed to match rule name');\r\n        return null;\r\n    }\r\n\r\n    const name = nameMatch[1];\r\n    console.log('Parsing rule:', name);\r\n\r\n    const strings: YaraString[] = [];\r\n    // Fixed regex patterns to better match the YARA format\r\n    const metadataMatch = block.match(/meta:\\s*([\\s\\S]*?)(?=strings:|condition:|$)/);\r\n    const stringsMatch = block.match(/strings:\\s*([\\s\\S]*?)(?=condition:|$)/);\r\n    const conditionMatch = block.match(/condition:\\s*([\\s\\S]*?)(?=}|$)/);\r\n\r\n    let metadata = {};\r\n    if (metadataMatch) {\r\n        console.log('Found metadata block:', metadataMatch[1]);\r\n        metadata = parseMetadata(metadataMatch[1]);\r\n    }\r\n\r\n    if (stringsMatch) {\r\n        console.log('Found strings block:', stringsMatch[1]);\r\n        strings.push(...parseStrings(stringsMatch[1]));\r\n    }\r\n\r\n    const result = {\r\n        name,\r\n        strings,\r\n        condition: conditionMatch ? conditionMatch[1].trim() : 'true',\r\n        metadata\r\n    };\r\n    \r\n    console.log('Parsed rule result:', JSON.stringify(result, null, 2));\r\n    return result;\r\n}\r\n\r\nfunction parseMetadata(metadataBlock: string): Record<string, string> {\r\n    const metadata: Record<string, string> = {};\r\n    const lines = metadataBlock.trim().split('\\n');\r\n    \r\n    for (const line of lines) {\r\n        // Fixed regex to better match metadata format\r\n        const match = line.match(/\\s*(\\w+)\\s*=\\s*[\"']([^\"']+)[\"']/);\r\n        if (match) {\r\n            metadata[match[1]] = match[2];\r\n        }\r\n    }\r\n    \r\n    return metadata;\r\n}\r\n\r\nfunction parseStrings(stringsBlock: string): YaraString[] {\r\n    const strings: YaraString[] = [];\r\n    const lines = stringsBlock.trim().split('\\n');\r\n    \r\n    for (const line of lines) {\r\n        // Fixed regex to better match string definitions\r\n        const match = line.match(/\\s*\\$(\\w+)\\s*=\\s*(?:\\/(.+)\\/|\"([^\"]+)\")/);\r\n        if (match) {\r\n            const identifier = match[1];\r\n            const value = match[2] || match[3]; // match[2] for regex, match[3] for literal strings\r\n            console.log(`Parsed string: ${identifier} = ${value}`);\r\n            strings.push({\r\n                identifier,\r\n                value,\r\n                isRegex: !!match[2] // true if the value was matched as a regex\r\n            });\r\n        }\r\n    }\r\n    \r\n    return strings;\r\n}\r\n"],
  "mappings": "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",
  "names": ["vscode"]
}
