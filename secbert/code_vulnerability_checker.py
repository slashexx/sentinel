import argparse
import sys

def check_dependencies():
    required_packages = {
        'transformers': 'transformers',
        'torch': 'torch',
        'urllib3': 'urllib3',
        'requests': 'requests',
        'huggingface_hub': 'huggingface-hub'
    }
    
    missing_packages = []
    for package, pip_name in required_packages.items():
        try:
            __import__(package)
        except ImportError:
            missing_packages.append(pip_name)
    
    if missing_packages:
        print("Error: Some required packages are missing.")
        print("Please install the following packages:")
        print(f"pip install {' '.join(missing_packages)}")
        print("\nIf you encounter urllib3 errors, try:")
        print("pip uninstall urllib3")
        print("pip install urllib3==1.26.6")
        sys.exit(1)

check_dependencies()
from transformers import pipeline
import re

def initialize_secbert():
    """Initialize SecBERT pipeline for vulnerability detection."""
    return pipeline("fill-mask", model="jackaduma/SecBERT")

def check_code_vulnerability(code: str, pipe) -> list:
    """
    Check code for potential security vulnerabilities using SecBERT.
    """
    # Enhanced vulnerability patterns
    patterns = [
        "SELECT * FROM [MASK]",
        "exec([MASK])",
        "eval([MASK])",
        "password = [MASK]",
        "TOKEN = [MASK]",
        "mysql://[MASK]",
        "username = [MASK]",
        "PASSWORD = [MASK]",
        "API_TOKEN = [MASK]",
        "connection_string = [MASK]"
    ]
    
    # Additional direct pattern matching without BERT
    direct_patterns = {
        r"password\s*=\s*['\"][^'\"]+['\"]": "Hardcoded password found",
        r"token\s*=\s*['\"][^'\"]+['\"]": "Hardcoded token found",
        r"exec\s*\(": "Dangerous exec() usage",
        r"eval\s*\(": "Dangerous eval() usage",
        r"SELECT.*\+.*(?:user|input)": "Potential SQL injection",
        r"mysql:\/\/.*:.*@": "Exposed database credentials",
    }
    
    findings = []
    
    # Check with SecBERT patterns
    for pattern in patterns:
        results = pipe(pattern)
        for result in results:
            if result['score'] > 0.7:
                findings.append({
                    'pattern': pattern,
                    'prediction': result['token_str'],
                    'confidence': result['score'],
                    'type': 'BERT detection'
                })
    
    # Check with direct patterns
    for pattern, message in direct_patterns.items():
        if re.search(pattern, code, re.IGNORECASE):
            findings.append({
                'pattern': pattern,
                'prediction': message,
                'confidence': 1.0,
                'type': 'Pattern match'
            })
    
    return findings

def read_file(filepath):
    """Read and return the contents of a file."""
    try:
        with open(filepath, 'r', encoding='utf-8') as file:
            return file.read()
    except Exception as e:
        print(f"Error reading file: {str(e)}")
        return None

def main():
    try:
        parser = argparse.ArgumentParser(description='Check code for security vulnerabilities using SecBERT')
        parser.add_argument('--code', type=str, help='Code to analyze')
        parser.add_argument('--file', type=str, help='Path to file to analyze')
        parser.add_argument('--interactive', action='store_true', help='Run in interactive mode')
        args = parser.parse_args()

        # Initialize the pipeline
        print("Initializing SecBERT model...")
        pipe = initialize_secbert()

        if args.file:
            print(f"Analyzing file: {args.file}")
            code = read_file(args.file)
            if code:
                vulnerabilities = check_code_vulnerability(code, pipe)
                if not vulnerabilities:
                    print("No potential vulnerabilities found in file.")
                else:
                    print("\nPotential vulnerabilities found in file:")
                    for vuln in vulnerabilities:
                        print(f"Type: {vuln['type']}")
                        print(f"Issue: {vuln['prediction']}")
                        if vuln['type'] == 'BERT detection':
                            print(f"Pattern: {vuln['pattern']}")
                            print(f"Confidence: {vuln['confidence']:.2f}")
                        print("---")
        elif args.interactive:
            while True:
                print("\nEnter code to analyze (or 'quit' to exit):")
                code = input()
                if code.lower() == 'quit':
                    break
                vulnerabilities = check_code_vulnerability(code, pipe)
                if not vulnerabilities:
                    print("No potential vulnerabilities found.")
                    continue
                print("\nPotential vulnerabilities found:")
                for vuln in vulnerabilities:
                    print(f"Type: {vuln['type']}")
                    print(f"Issue: {vuln['prediction']}")
                    if vuln['type'] == 'BERT detection':
                        print(f"Pattern: {vuln['pattern']}")
                        print(f"Confidence: {vuln['confidence']:.2f}")
                    print("---")
        elif args.code:
            vulnerabilities = check_code_vulnerability(args.code, pipe)
            if not vulnerabilities:
                print("No potential vulnerabilities found.")
            else:
                print("\nPotential vulnerabilities found:")
                for vuln in vulnerabilities:
                    print(f"Type: {vuln['type']}")
                    print(f"Issue: {vuln['prediction']}")
                    if vuln['type'] == 'BERT detection':
                        print(f"Pattern: {vuln['pattern']}")
                        print(f"Confidence: {vuln['confidence']:.2f}")
                    print("---")
        else:
            parser.print_help()
    except Exception as e:
        print(f"An error occurred: {str(e)}")
        print("If this is a model loading error, check your internet connection.")
        sys.exit(1)

if __name__ == "__main__":
    main()
